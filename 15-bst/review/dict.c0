/********************/
/* Client interface */
/********************/

//typedef ______ key;
//typedef ______* entry;

key entry_key(entry e)
/*@requires e != NULL; @*/;

int key_compare(key k1, key k2);

/***********************/
/* Dict implementation */
/***********************/

/* Tree */
typedef struct tree_node tree;
struct tree_node 
{
	entry data; // Non NULL
	tree* left;
	tree* right;
};

typedef struct dict_header dict;
struct dict_header 
{
	tree* root;
	int size;
};

bool is_tree(tree* root) 
{
	if (root == NULL) return true;
	return root->data != NULL 
			&& is_tree(root->left)
			&& is_tree(root->right);
}
/* Tree end */

/* Ordering invariant: at any node with key k 
	 keys of all entries on the left tree is less than k
	 keys of all entries on the right tree is greater than k */

/* BST */
bool is_bst(tree* T) {
	return is_tree(T);
	// also check the order invariant
}


entry bst_lookup(tree* T, key k)
//@requires is_bst(T);
/*@ensures \result == NULL
				 || key_compare(entry_key(\result), k) == 0; @*/
{
	if (T == NULL) return NULL;

	int cmp = key_compare(k, entry_key(T->data));
	if (cmp == 0) return T->data;
	else if (cmp > 0) return bst_lookup(T->right, k);
	return bst_lookup(T->left, k);
}

tree* bst_insert(dict* D, tree* T, entry e)
//@requires is_bst(T) && e != NULL;
//@ensures is_bst(\result) && \result != NULL;
//@ensures bst_lookup(\result, entry_key(e)) == e;
{
	if (T == NULL) {
		tree* R = alloc(tree);
		R->data = e;
		(D->size)++;
		return R;
	}

	int cmp = key_compare(entry_key(e), entry_key(T->data));
	if (cmp == 0) T->data = e;
	else if (cmp < 0) T->left = bst_insert(D, T->left, e);
	else {
		T->right = bst_insert(D, T->right, e);
	}
	return T;
}
/* BST end */

/* DICT */

bool is_dict(dict* D) 
{
	return is_bst(D->root);
}

dict* dict_new()
/*@ensures \result != NULL; @*/
{
	dict* D = alloc(dict);
	D->size = 0;
	return D;
}

entry dict_lookup(dict* D, key k)
//@requires D != NULL;
/*@ensures \result == NULL
				 || key_compare(entry_key(\result), k) == 0; @*/
{
	return bst_lookup(D->root, k);
}

void dict_insert(dict* D, entry e)
//@requires is_dict(D) && e != NULL;
//@ensures dict_lookup(D, entry_key(e)) == e;
{
	D->root = bst_insert(D, D->root, e);
}

int dict_size(dict* D)
//requires D != NULL;
{
	return D->size;
}

/* DICT end */

/******************/
/* Dict interface */
/******************/

typedef dict* dict_t;

dict_t dict_new()
/*@ensures \result != NULL; @*/ ;

int dict_size(dict_t D)
/*@requires D != NULL; @*/ ;

entry dict_lookup(dict_t D, key k)
/*@requires D != NULL; @*/
/*@ensures \result == NULL
				|| key_compare(entry_key(\result), k) == 0; @*/ ;

void dict_insert(dict_t D, entry e)
/*@requires D != NULL && e != NULL; @*/
/*@ensures dict_lookup(D, entry_key(e)) != NULL; @*/ ;

