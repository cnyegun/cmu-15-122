#use <conio>
#use <util>
/* BSTs are good only if they're balanced */
/* Let's balance it */

typedef int key;
typedef struct person* entry;
struct person { 
	int id;		 	//key
	string name; 	// other data(s)
};

typedef struct tree_node tree;
struct tree_node {
	entry data;  // Non-NULL
	int height;
	tree* left;
	tree* right;
};

int entry_key(entry e) {
	return e->id;
}

int key_compare(key k1, key k2) {
	if (k1 == k2) return 0;
	return k1 > k2 ? 1 : -1;
}

bool is_tree(tree* root) {
	if (root == NULL) return true;
	return root->data != NULL 
		&& is_tree(root->left) 
		&& is_tree(root->right);
}

tree* rotate_left(tree* T)
//@requires T != NULL && T->right != NULL;
{
	tree* R = T->right;
	T->right = R->left;
	R->left = T;
	return R;
}

tree* rotate_right(tree* T)
//@requires T != NULL && T->left != NULL;
{
	tree* R = T->left;
	T->left = R->right;
	R->right = T;
	return R;
}


bool is_balanced(tree* T) {
	if (T == NULL) return true;
	return abs(height(T->left) - height(T->right)) <= 1
		&& is_balanced(T->left) && is_balanced(T->right);
}

bool is_ordered(tree* T, entry lo, entry hi)
//@requires is_tree(T);
{
	if (T == NULL) return true;
	key k = entry_key(T->data);
	return T->data != NULL
		&& (lo == NULL || key_compare(k, entry_key(lo)) > 0)
		&& (hi == NULL || key_compare(k, entry_key(hi)) < 0)
		&& is_ordered(T->left, lo, T->data)
		&& is_ordered(T->right, T->data, hi);
}

int tree_height(tree* T) {
	if (T == NULL) return 0;
	return 1 + max(tree_height(T->left), tree_height(T->right));
}

int balance_factor(tree* T)
//@requires T != NULL;
{
	return tree_height(T->left) - tree_height(T->left);
}

int main() {
	return 0;
}
