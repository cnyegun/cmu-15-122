#use <conio>
#use <util>

/************************CLIENT*DEFINITION******************************/

typedef int key;
typedef struct entry_header* entry;
struct entry_header {
    int key;        // integer key
    string value;    // stored value
};

key entry_key(entry e) 
//@requires e != NULL;
{
    return e->key;
}

int key_compare(key k1, key k2) {
    if (k1 == k2) return 0;
    return k1 > k2 ? 1 : -1;
}

entry make_entry(key k, string value)
//@ensures \result != NULL;
{
    entry R = alloc(struct entry_header);
    R->key = k;
    R->value = value;
    return R;
}

void print_entry(entry e) {
    if (e == NULL) {
        print("NULL\n");
        return;
    }
    printf("KEY: %d -> VALUE: %s\n", e->key, e->value);
}

/************************AVL*TREE*DEFINITION****************************/
typedef struct tree_node tree;
struct tree_node {
    entry data;     // Non-NULL
    int height;
    tree* left;
    tree* right;
};

int height(tree* T) {
    return T == NULL ? 0 : T->height;
}

bool is_tree(tree* T)
{
    if (T == NULL) return true;
    return is_tree(T->left)
        && is_tree(T->right);
}

bool is_specified_height(tree* T) {
    if (T == NULL) return true;
    return is_specified_height(T->left)
        && is_specified_height(T->right)
        && T->height == max(height(T->left), 
                            height(T->right)) + 1;
}

bool is_balanced(tree* T) {
    if (T == NULL) return true;
    return abs(height(T->left) - height(T->right)) <= 1
        && is_balanced(T->left) && is_balanced(T->right);
}

bool is_ordered(tree* T, entry lo, entry hi)
//@requires is_tree(T);
{
    if (T == NULL) return true;
    key k = entry_key(T->data);
    return (lo == NULL || key_compare(k, entry_key(lo)) > 0)
        && (hi == NULL || key_compare(k, entry_key(hi)) < 0)
        && (is_ordered(T->left, lo, T->data))
        && (is_ordered(T->right, T->data, hi));
}

bool is_avl(tree* T) {
    return is_tree(T) && is_ordered(T, NULL, NULL)
        && is_specified_height(T)
        && is_balanced(T);
}

entry avl_lookup(tree* T, key k)
//@requires is_avl(T);
/*@ensures \result == NULL
        || key_compare(entry_key(\result), k) == 0; @*/
{
    if (T == NULL) return NULL;
    int cmp = key_compare(k, entry_key(T->data));
    if (cmp == 0) return T->data;
    else if (cmp > 0) return avl_lookup(T->right, k);
    else {
        return avl_lookup(T->left, k);
    }
}

void fix_height(tree* T) 
//@requires T != NULL;
//@ensures is_specified_height(T->left);
//@ensures is_specified_height(T->right);
{
    int hl = height(T->left);
    int hr = height(T->right);
    T->height = hl > hr ? hl + 1 : hr + 1;
    return;
}

tree* rotate_left(tree* T) 
//@requires T != NULL && T->right != NULL;
//@requires is_specified_height(T->left);
//@requires is_specified_height(T->right);
//@ensures is_specified_height(\result);
{
    tree* R = T->right;
    T->right = R->left;
    R->left = T;
    fix_height(T);
    fix_height(R);
    return R;
}

tree* rotate_right(tree* T) 
//@requires T != NULL && T->left!= NULL;
//@requires is_specified_height(T->left);
//@requires is_specified_height(T->right);
//@ensures is_specified_height(\result);
{
    tree* R = T->left;
    T->left = R->right;
    R->right = T;
    fix_height(T);
    fix_height(R);
    return R;
}

tree* rebalance_right(tree* T)
//@requires T != NULL && T->right != NULL;
//@requires is_avl(T->left) && is_avl(T->right);
//@ensures is_avl(\result);
{
    if (height(T->right) - height(T->left) == 2) {
        if (height(T->right->right) > height(T->right->left)) {
            // Single rotation
            T = rotate_left(T);
        } else {
            T->right = rotate_right(T->right);
            T = rotate_left(T);
        }
    } else {
        fix_height(T);
    }
    return T;
} 

tree* rebalance_left(tree* T)
//@requires T != NULL && T->right != NULL;
//@requires is_avl(T->left) && is_avl(T->right);
//@ensures is_avl(\result);
{
    if (height(T->left) - height(T->right) == 2) {
        if (height(T->left->left) > height(T->left->right)) {
            // Single rotation
            T = rotate_right(T);
        } else {
            T->left = rotate_left(T->left);
            T = rotate_right(T);
        }
    } else {
        fix_height(T);
    }
    return T;
} 

tree* leaf(entry e)
//@requires e != NULL;
//@ensures is_avl(\result) && \result != NULL;
{
    tree* T = alloc(tree);
    T->data = e;
    T->height = 1;
    return T;
}

tree* avl_insert(tree* T, entry e)
//@requires is_avl(T) && e != NULL;
//@ensures is_avl(\result) && \result != NULL;
//@ensures avl_lookup(\result, entry_key(e)) == e;
{
    if (T == NULL) return leaf(e);
    int cmp = key_compare(entry_key(e), entry_key(T->data));
    if (cmp == 0) {
        T->data = e;
    }
    else if (cmp > 0) {
        T->right = avl_insert(T->right, e);
        T = rebalance_right(T);
    }
    else {
        T->left = avl_insert(T->left, e);
        T = rebalance_left(T);
    }
    return T;
}

/******************************DRIVER***********************************/

int main() {
    tree* root = NULL;
    root = avl_insert(root, make_entry(5, "Five"));
    root = avl_insert(root, make_entry(3, "Three"));
    root = avl_insert(root, make_entry(1, "One"));
    root = avl_insert(root, make_entry(4, "Four"));
    //@assert is_ordered(root, NULL, NULL);
    print_entry(avl_lookup(root, 3));
    print_entry(avl_lookup(root, 5));
    print_entry(avl_lookup(root, 7));
    print_entry(avl_lookup(root, 8));
    printf("All tests passed!\n");
    return 0;
}
