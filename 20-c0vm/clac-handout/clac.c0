/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2023                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Clac, stack-based calculator language
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/* From the perspective of the clac-main.c0 file, state_t is an
 * abstract type. (typedef ____* state_t) This file contains the
 * implementation of the state_t type. You will need to modify
 * this type when you do task 3. */
typedef bool *state_t; // MODIFY ME
state_t init_state()
//@ensures \result != NULL;
{
  // UPDATE ME
  return alloc(bool); // MODIFY ME
}

int[] get_ops(stack_t S, int n)
//@requires S != NULL;
//@requires n > 0;
{
  int[] ops = alloc_array(int, n);
  for (int i = 0; i < n; i++) {
    if (!stack_empty(S)) {
      ops[i] = pop(S);
    } else {
      error("Not enough operands");
    }
  }
  return ops;
}

int pow(int x,int y)
//@requires y >= 0;
{
  int result = 1;
  for (int i = 0; i < y; i++) {
    result *= x;
  }
  return result;
}

/* Main clac interpreter. */
/* Return true: clac top-level interpreter will expect more input */
/* Return false: clac top-level interpreter will exit */
bool eval(queue_t inputQ, stack_t S, state_t ST)
//@requires inputQ != NULL && S != NULL && ST != NULL;
//@ensures \result == false || queue_empty(inputQ);
{
  queue_t Q = inputQ;

  while (!queue_empty(Q)) {
    string tok = deq(Q);
    printf("Read: %s\n", tok);

    if (string_equal(tok, "print")) {
      
      if (!stack_empty(S)) {
        int x = pop(S);
        printf("%d\n", x);
      } else {
        println("The stack is empty. Couldn't perform `print`.");
      }

    } else if (string_equal(tok, "quit")) {
      return false;

    } else if (string_equal(tok, "+")) {
      int[] ops = get_ops(S, 2);
      push(S, ops[0] + ops[1]);
    } else if (string_equal(tok, "-")) {
      int[] ops = get_ops(S, 2);
      push(S, ops[0] - ops[1]);
    } else if (string_equal(tok, "*")) {
      int[] ops = get_ops(S, 2);
      push(S, ops[0] * ops[1]);
    } else if (string_equal(tok, "/")) {
      int[] ops = get_ops(S, 2);
      if (ops[1] == 0) {
        error("Division by zero");
      } else if (ops[0] == int_min() && ops[1] == -1) {
        error("int_min() / -1");
      }
      push(S, ops[0] / ops[1]);
    } else if (string_equal(tok, "%")) {
      int[] ops = get_ops(S, 2);
      if (ops[1] == 0) {
        error("Modulus by zero");
      } else if (ops[0] == int_min() && ops[1] == -1) {
        error("int_min() % -1");
      }
      push(S, ops[0] % ops[1]);
    } else if (string_equal(tok, "**")) {
      int[] ops = get_ops(S, 2);
      if (ops[1] < 0) {
        error("Second operand cannot be negative");
      }
      push(S, pow(ops[0], ops[1]));
    } else if (string_equal(tok, "<")) {
      int[] ops = get_ops(S, 2);
      push(S, ops[0] < ops[1] ? 1 : 0);
    } else if (string_equal(tok, "drop")) {
      if (!stack_empty(S)) {
        pop(S);
      } else {
        error("Stack is empty. Couldn't perform `drop`");
      }
    } else if (string_equal(tok, "swap")) {
      int[] ops = get_ops(S, 2);
      push(S, ops[1]);
      push(S, ops[0]);
    } else if (string_equal(tok, "rot")) {
      int[] ops = get_ops(S, 3);
      push(S, ops[1]);
      push(S, ops[0]);
      push(S, ops[2]);
    }

    else {
      /* Not defined as an operation name, should be an int */
      int *p = parse_int(tok, 10);
      if (p == NULL) { /* not an int */
        /* call error(msg) which prints msg and aborts */
        error(string_join("undefined token ", tok));
      }
      push(S, *p);
    }
  }

  /* When you return "true", don't pop anything off the stack! When we
   * grade your function, we'll check that the stack contains the
   * integers we expect. */
  return true;
}
